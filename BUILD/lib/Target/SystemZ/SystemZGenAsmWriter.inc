//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void SystemZAsmPrinter::printInstruction(const MachineInstr *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    268435467U,	// ADC32ri
    269484049U,	// ADC32rr
    268435478U,	// ADC64ri32
    269484061U,	// ADC64rr
    268435491U,	// ADD32ri
    270532648U,	// ADD32ri16
    271581229U,	// ADD32rm
    271581232U,	// ADD32rmy
    269484084U,	// ADD32rr
    270532664U,	// ADD64ri16
    268435518U,	// ADD64ri32
    271581252U,	// ADD64rm
    269484104U,	// ADD64rr
    269484109U,	// ADDE32rr
    269484115U,	// ADDE64rr
    90U,	// ADJCALLSTACKDOWN
    108U,	// ADJCALLSTACKUP
    269484156U,	// AND32ri
    269484162U,	// AND32rilh16
    269484168U,	// AND32rill16
    271581326U,	// AND32rm
    271581329U,	// AND32rmy
    269484181U,	// AND32rr
    269484185U,	// AND64rihh16
    269484191U,	// AND64rihi32
    269484197U,	// AND64rihl16
    269484162U,	// AND64rilh16
    269484168U,	// AND64rill16
    269484156U,	// AND64rilo32
    271581355U,	// AND64rm
    269484207U,	// AND64rr
    536871092U,	// BSWAP32mr
    272629946U,	// BSWAP32rm
    273678527U,	// BSWAP32rr
    536871109U,	// BSWAP64mr
    272629964U,	// BSWAP64rm
    273678546U,	// BSWAP64rr
    805306585U,	// CALLi
    285212902U,	// CALLr
    274727154U,	// CMP32ri
    272630007U,	// CMP32rm
    272630010U,	// CMP32rmy
    273678590U,	// CMP32rr
    274727170U,	// CMP64ri32
    272630024U,	// CMP64rm
    273678604U,	// CMP64rr
    272630033U,	// CMPSX64rm32
    273678614U,	// CMPSX64rr32
    273678620U,	// FABS32rr
    273678627U,	// FABS64rr
    271581482U,	// FADD32rm
    269484335U,	// FADD32rr
    271581493U,	// FADD64rm
    269484346U,	// FADD64rr
    273678656U,	// FBCONVF64
    273678662U,	// FBCONVG64
    272630092U,	// FCMP32rm
    273678673U,	// FCMP32rr
    272630103U,	// FCMP64rm
    273678684U,	// FCMP64rr
    273678690U,	// FCONVFP32
    273678697U,	// FCONVFP32r64
    273678704U,	// FCONVFP64
    273678711U,	// FCONVFP64r32
    301990270U,	// FCONVGR32
    301990277U,	// FCONVGR32r64
    301990284U,	// FCONVGR64
    301990291U,	// FCONVGR64r32
    269746586U,	// FCOPYSIGN32
    269746586U,	// FCOPYSIGN64
    271581601U,	// FDIV32rm
    269484454U,	// FDIV32rr
    271581612U,	// FDIV64rm
    269484465U,	// FDIV64rr
    272630199U,	// FEXT32m64
    273678781U,	// FEXT32r64
    273678788U,	// FLOGR64
    275775947U,	// FMADD32rm
    276824529U,	// FMADD32rr
    275775960U,	// FMADD64rm
    276824542U,	// FMADD64rr
    536871397U,	// FMOV32mr
    536871402U,	// FMOV32mry
    272630256U,	// FMOV32rm
    272630260U,	// FMOV32rmy
    273678841U,	// FMOV32rr
    536871422U,	// FMOV64mr
    536871427U,	// FMOV64mry
    272630281U,	// FMOV64rm
    272630285U,	// FMOV64rmy
    273678866U,	// FMOV64rr
    275776023U,	// FMSUB32rm
    276824605U,	// FMSUB32rr
    275776036U,	// FMSUB64rm
    276824618U,	// FMSUB64rr
    271581745U,	// FMUL32rm
    269484599U,	// FMUL32rr
    271581758U,	// FMUL64rm
    269484611U,	// FMUL64rr
    273678921U,	// FNABS32rr
    273678928U,	// FNABS64rr
    273678935U,	// FNEG32rr
    273678942U,	// FNEG64rr
    273678949U,	// FROUND64r32
    272630380U,	// FSQRT32rm
    273678962U,	// FSQRT32rr
    272630393U,	// FSQRT64rm
    273678975U,	// FSQRT64rr
    271581830U,	// FSUB32rm
    269484683U,	// FSUB32rr
    271581841U,	// FSUB64rm
    269484694U,	// FSUB64rr
    285213340U,	// JE
    285213344U,	// JH
    285213348U,	// JHE
    285213353U,	// JL
    285213357U,	// JLE
    285213362U,	// JLH
    285213367U,	// JMP
    285213370U,	// JMPr
    285213374U,	// JNE
    285213379U,	// JNH
    285213384U,	// JNHE
    285213390U,	// JNL
    285213395U,	// JNLE
    285213401U,	// JNLH
    285213407U,	// JNO
    285213412U,	// JO
    272630504U,	// LA64r
    273679085U,	// LA64rm
    285213427U,	// LD_Fp032
    285213433U,	// LD_Fp064
    1124074239U,	// MOV128mr
    1342178070U,	// MOV128r0_even
    1687159580U,	// MOV128rm
    1621623602U,	// MOV128rr
    1962935113U,	// MOV16mi
    536871760U,	// MOV32m16r
    536871765U,	// MOV32m16ry
    536871771U,	// MOV32m8r
    536871776U,	// MOV32m8ry
    1979712358U,	// MOV32mi16
    536871788U,	// MOV32mr
    2147484528U,	// MOV32mrm
    536871798U,	// MOV32mry
    279970683U,	// MOV32ri16
    272630656U,	// MOV32rm
    274072451U,	// MOV32rmm
    272630664U,	// MOV32rmy
    273679244U,	// MOV32rr
    1191183248U,	// MOV64Pmr
    1207960486U,	// MOV64Pmry
    1342178171U,	// MOV64Pr0_even
    1690305469U,	// MOV64Prm
    1691354066U,	// MOV64Prmy
    536871760U,	// MOV64m16r
    536871765U,	// MOV64m16ry
    536871788U,	// MOV64m32r
    536871798U,	// MOV64m32ry
    536871771U,	// MOV64m8r
    536871776U,	// MOV64m8ry
    1979712488U,	// MOV64mi16
    536871919U,	// MOV64mr
    2147484660U,	// MOV64mrm
    279970582U,	// MOV64ri16
    274727930U,	// MOV64ri32
    273679360U,	// MOV64rihh16
    273679367U,	// MOV64rihi32
    273679374U,	// MOV64rihl16
    273679381U,	// MOV64rilh16
    273679388U,	// MOV64rill16
    273679395U,	// MOV64rilo32
    272630826U,	// MOV64rm
    274072622U,	// MOV64rmm
    273679411U,	// MOV64rr
    1621886008U,	// MOV64rrP
    2030044238U,	// MOV8mi
    2030044243U,	// MOV8miy
    272630873U,	// MOVSX32rm16
    272630877U,	// MOVSX32rm16y
    272630882U,	// MOVSX32rm8
    273679462U,	// MOVSX32rr16
    273679467U,	// MOVSX32rr8
    272630896U,	// MOVSX64rm16
    272630901U,	// MOVSX64rm32
    272630906U,	// MOVSX64rm8
    273679487U,	// MOVSX64rr16
    273679493U,	// MOVSX64rr32
    273679499U,	// MOVSX64rr8
    272630929U,	// MOVZX32rm16
    272630934U,	// MOVZX32rm8
    272630939U,	// MOVZX64rm16
    272630945U,	// MOVZX64rm32
    272630951U,	// MOVZX64rm8
    273679533U,	// MOVZX64rr32
    268436660U,	// MUL32ri
    270533818U,	// MUL32ri16
    271582399U,	// MUL32rm
    271582403U,	// MUL32rmy
    269485256U,	// MUL32rr
    270533837U,	// MUL64ri16
    268436691U,	// MUL64ri32
    271582426U,	// MUL64rm
    269485279U,	// MUL64rr
    269485285U,	// MUL64rrP
    269485289U,	// MULSX64rr32
    273679600U,	// NEG32rr
    273679605U,	// NEG64rr
    273679611U,	// NEG64rr32
    1282U,	// NOP
    269485322U,	// OR32ri
    269485328U,	// OR32ri16
    269485334U,	// OR32ri16h
    271582492U,	// OR32rm
    271582495U,	// OR32rmy
    269485347U,	// OR32rr
    269485351U,	// OR64rihh16
    269485357U,	// OR64rihi32
    269485363U,	// OR64rihl16
    269485334U,	// OR64rilh16
    269485328U,	// OR64rill16
    269485322U,	// OR64rilo32
    271582521U,	// OR64rm
    269485373U,	// OR64rr
    1346U,	// RET
    274072906U,	// ROTL32rri
    274072911U,	// ROTL64rri
    268436821U,	// SBC32ri
    269485404U,	// SBC32rr
    268436833U,	// SBC64ri32
    269485416U,	// SBC64rr
    271582574U,	// SDIVREM32m
    269485428U,	// SDIVREM32r
    271582587U,	// SDIVREM64m
    269485440U,	// SDIVREM64r
    2415920518U,	// SHL32rri
    274072971U,	// SHL64rri
    2415920529U,	// SRA32rri
    274072982U,	// SRA64rri
    2415920540U,	// SRL32rri
    274072993U,	// SRL64rri
    271582631U,	// SUB32rm
    271582634U,	// SUB32rmy
    269485486U,	// SUB32rr
    271582642U,	// SUB64rm
    269485494U,	// SUB64rr
    269485499U,	// SUBE32rr
    269485505U,	// SUBE64rr
    1480U,	// Select32
    1498U,	// Select64
    1516U,	// SelectF32
    1535U,	// SelectF64
    273679890U,	// UCMP32ri
    272631320U,	// UCMP32rm
    272631324U,	// UCMP32rmy
    273679905U,	// UCMP32rr
    273679910U,	// UCMP64ri32
    272631341U,	// UCMP64rm
    273679922U,	// UCMP64rr
    272631352U,	// UCMPZX64rm32
    273679934U,	// UCMPZX64rr32
    271582789U,	// UDIVREM32m
    269485641U,	// UDIVREM32r
    271582798U,	// UDIVREM64m
    269485651U,	// UDIVREM64r
    269485657U,	// UMUL128rrP
    269485663U,	// UMUL64rrP
    269485668U,	// XOR32ri
    271582826U,	// XOR32rm
    271582829U,	// XOR32rmy
    269485681U,	// XOR32rr
    271582837U,	// XOR64rm
    269485689U,	// XOR64rr
    0U
  };

  const char *AsmStrs = 
    "DBG_VALUE\000alfi\t\000alr\t\000algfi\t\000algr\t\000afi\t\000ahi\t\000"
    "a\t\000ay\t\000ar\t\000aghi\t\000agfi\t\000ag\t\000agr\t\000alcr\t\000a"
    "lcgr\t\000#ADJCALLSTACKDOWN\000#ADJCALLSTACKUP\000nilf\t\000nilh\t\000n"
    "ill\t\000n\t\000ny\t\000nr\t\000nihh\t\000nihf\t\000nihl\t\000ng\t\000n"
    "gr\t\000strv\t\000lrv\t\000lrvr\t\000strvg\t\000lrvg\t\000lrvgr\t\000br"
    "asl\t%r14, \000basr\t%r14, \000cfi\t\000c\t\000cy\t\000cr\t\000cgfi\t\000"
    "cg\t\000cgr\t\000cgf\t\000cgfr\t\000lpebr\t\000lpdbr\t\000aeb\t\000aebr"
    "\t\000adb\t\000adbr\t\000ldgr\t\000lgdr\t\000ceb\t\000cebr\t\000cdb\t\000"
    "cdbr\t\000cefbr\t\000cegbr\t\000cdgbr\t\000cdfbr\t\000cfebr\t\000cfdbr\t"
    "\000cgdbr\t\000cgebr\t\000cpsdr\t\000deb\t\000debr\t\000ddb\t\000ddbr\t"
    "\000ldeb\t\000ldebr\t\000flogr\t\000maeb\t\000maebr\t\000madb\t\000madb"
    "r\t\000ste\t\000stey\t\000le\t\000ley\t\000ler\t\000std\t\000stdy\t\000"
    "ld\t\000ldy\t\000ldr\t\000mseb\t\000msebr\t\000msdb\t\000msdbr\t\000mee"
    "b\t\000meebr\t\000mdb\t\000mdbr\t\000lnebr\t\000lndbr\t\000lcebr\t\000l"
    "cdbr\t\000ledbr\t\000sqeb\t\000sqebr\t\000sqdb\t\000sqdbr\t\000seb\t\000"
    "sebr\t\000sdb\t\000sdbr\t\000je\t\000jh\t\000jhe\t\000jl\t\000jle\t\000"
    "jlh\t\000j\t\000br\t\000jne\t\000jnh\t\000jnhe\t\000jnl\t\000jnle\t\000"
    "jnlh\t\000jno\t\000jo\t\000lay\t\000larl\t\000lzer\t\000lzdr\t\000# MOV"
    "128 PSEUDO!\n\tstg\t\000lghi\t\000# MOV128 PSEUDO!\n\tlg\t\000# MOV128 "
    "PSEUDO!\n\tlgr\t\000mvhhi\t\000sth\t\000sthy\t\000stc\t\000stcy\t\000mv"
    "hi\t\000st\t\000stmy\t\000sty\t\000lhi\t\000l\t\000lmy\t\000ly\t\000lr\t"
    "\000# MOV64P PSEUDO!\n\tst\t\000# MOV64P PSEUDO!\n\tsty\t\000# MOV64P P"
    "SEUDO!\n\tl\t\000# MOV64P PSEUDO!\n\tly\t\000mvghi\t\000stg\t\000stmg\t"
    "\000lgfi\t\000llihh\t\000llihf\t\000llihl\t\000llilh\t\000llill\t\000ll"
    "ilf\t\000lg\t\000lmg\t\000lgr\t\000# MOV64P PSEUDO!\n\tlr\t\000mvi\t\000"
    "mviy\t\000lh\t\000lhy\t\000lb\t\000lhr\t\000lbr\t\000lgh\t\000lgf\t\000"
    "lgb\t\000lghr\t\000lgfr\t\000lgbr\t\000llh\t\000llc\t\000llgh\t\000llgf"
    "\t\000llgc\t\000llgfr\t\000msfi\t\000mhi\t\000ms\t\000msy\t\000msr\t\000"
    "mghi\t\000msgfi\t\000msg\t\000msgr\t\000mr\t\000msgfr\t\000lcr\t\000lcg"
    "r\t\000lcgfr\t\000# no-op\000oilf\t\000oill\t\000oilh\t\000o\t\000oy\t\000"
    "or\t\000oihh\t\000oihf\t\000oihl\t\000og\t\000ogr\t\000br\t%r14\000rll\t"
    "\000rllg\t\000sllfi\t\000slr\t\000slgfi\t\000slgr\t\000dsgf\t\000dsgfr\t"
    "\000dsg\t\000dsgr\t\000sll\t\000sllg\t\000sra\t\000srag\t\000srl\t\000s"
    "rlg\t\000s\t\000sy\t\000sr\t\000sg\t\000sgr\t\000slbr\t\000slbgr\t\000#"
    " Select32 PSEUDO\000# Select64 PSEUDO\000# SelectF32 PSEUDO\000# Select"
    "F64 PSEUDO\000clfi\t\000cl\t\000cly\t\000clr\t\000clgfi\t\000clg\t\000c"
    "lgr\t\000clgf\t\000clgfr\t\000dl\t\000dlr\t\000dlg\t\000dlgr\t\000mlgr\t"
    "\000mlr\t\000xilf\t\000x\t\000xy\t\000xr\t\000xg\t\000xgr\t\000";

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 2047)-1;


  // Fragment 0 encoded into 4 bits for 10 unique commands.
  switch ((Bits >> 28) & 15) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, ADJCALLSTACKDOWN, ADJCALLSTACKUP, NOP, RET, Select32, Selec...
    return;
    break;
  case 1:
    // ADC32ri, ADC32rr, ADC64ri32, ADC64rr, ADD32ri, ADD32ri16, ADD32rm, ADD...
    printOperand(MI, 0, O); 
    break;
  case 2:
    // BSWAP32mr, BSWAP64mr, FMOV32mr, FMOV32mry, FMOV64mr, FMOV64mry, MOV32m...
    printOperand(MI, 3, O); 
    O << ", "; 
    printRRIAddrOperand(MI, 0, O); 
    return;
    break;
  case 3:
    // CALLi
    printPCRelImmOperand(MI, 0, O); 
    return;
    break;
  case 4:
    // MOV128mr, MOV64Pmr, MOV64Pmry
    printOperand(MI, 3, O, "subreg_odd"); 
    O << ", "; 
    printRRIAddrOperand(MI, 0, O); 
    break;
  case 5:
    // MOV128r0_even, MOV64Pr0_even
    printOperand(MI, 0, O, "subreg_even"); 
    O << ", 0"; 
    return;
    break;
  case 6:
    // MOV128rm, MOV128rr, MOV64Prm, MOV64Prmy, MOV64rrP
    printOperand(MI, 0, O, "subreg_odd"); 
    break;
  case 7:
    // MOV16mi, MOV32mi16, MOV64mi16, MOV8mi, MOV8miy
    printRIAddrOperand(MI, 0, O); 
    O << ", "; 
    break;
  case 8:
    // MOV32mrm, MOV64mrm
    printOperand(MI, 2, O); 
    O << ", "; 
    printOperand(MI, 3, O); 
    O << ", "; 
    printRIAddrOperand(MI, 0, O); 
    return;
    break;
  case 9:
    // SHL32rri, SRA32rri, SRL32rri
    printOperand(MI, 1, O); 
    O << ", "; 
    printRIAddrOperand(MI, 2, O); 
    return;
    break;
  }


  // Fragment 1 encoded into 4 bits for 10 unique commands.
  switch ((Bits >> 24) & 15) {
  default:   // unreachable.
  case 0:
    // ADC32ri, ADC32rr, ADC64ri32, ADC64rr, ADD32ri, ADD32ri16, ADD32rm, ADD...
    O << ", "; 
    break;
  case 1:
    // CALLr, JE, JH, JHE, JL, JLE, JLH, JMP, JMPr, JNE, JNH, JNHE, JNL, JNLE...
    return;
    break;
  case 2:
    // FCONVGR32, FCONVGR32r64, FCONVGR64, FCONVGR64r32
    O << ", 5, "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 3:
    // MOV128mr
    O << "\n\tstg\t"; 
    printOperand(MI, 3, O, "subreg_even"); 
    O << ", 8+"; 
    printRRIAddrOperand(MI, 0, O); 
    return;
    break;
  case 4:
    // MOV128rm, MOV64Prm, MOV64Prmy
    O << ",  "; 
    printRRIAddrOperand(MI, 1, O); 
    break;
  case 5:
    // MOV16mi
    printS16ImmOperand(MI, 2, O); 
    return;
    break;
  case 6:
    // MOV32mi16, MOV64mi16
    printS32ImmOperand(MI, 2, O); 
    return;
    break;
  case 7:
    // MOV64Pmr
    O << "\n\tst\t"; 
    printOperand(MI, 3, O, "subreg_even"); 
    O << ", 4+"; 
    printRRIAddrOperand(MI, 0, O); 
    return;
    break;
  case 8:
    // MOV64Pmry
    O << "\n\tsty\t"; 
    printOperand(MI, 3, O, "subreg_even"); 
    O << ", 4+"; 
    printRRIAddrOperand(MI, 0, O); 
    return;
    break;
  case 9:
    // MOV8mi, MOV8miy
    printOperand(MI, 2, O); 
    return;
    break;
  }


  // Fragment 2 encoded into 4 bits for 14 unique commands.
  switch ((Bits >> 20) & 15) {
  default:   // unreachable.
  case 0:
    // ADC32ri, ADC64ri32, ADD32ri, ADD64ri32, MUL32ri, MUL64ri32, SBC32ri, S...
    printS32ImmOperand(MI, 2, O); 
    return;
    break;
  case 1:
    // ADC32rr, ADC64rr, ADD32rr, ADD64rr, ADDE32rr, ADDE64rr, AND32ri, AND32...
    printOperand(MI, 2, O); 
    break;
  case 2:
    // ADD32ri16, ADD64ri16, MUL32ri16, MUL64ri16
    printS16ImmOperand(MI, 2, O); 
    return;
    break;
  case 3:
    // ADD32rm, ADD32rmy, ADD64rm, AND32rm, AND32rmy, AND64rm, FADD32rm, FADD...
    printRRIAddrOperand(MI, 2, O); 
    return;
    break;
  case 4:
    // BSWAP32rm, BSWAP64rm, CMP32rm, CMP32rmy, CMP64rm, CMPSX64rm32, FCMP32r...
    printRRIAddrOperand(MI, 1, O); 
    return;
    break;
  case 5:
    // BSWAP32rr, BSWAP64rr, CMP32rr, CMP64rr, CMPSX64rr32, FABS32rr, FABS64r...
    printOperand(MI, 1, O); 
    break;
  case 6:
    // CMP32ri, CMP64ri32, MOV64ri32
    printS32ImmOperand(MI, 1, O); 
    return;
    break;
  case 7:
    // FMADD32rm, FMADD64rm, FMSUB32rm, FMSUB64rm
    printOperand(MI, 5, O); 
    O << ", "; 
    printRRIAddrOperand(MI, 2, O); 
    return;
    break;
  case 8:
    // FMADD32rr, FMADD64rr, FMSUB32rr, FMSUB64rr
    printOperand(MI, 3, O); 
    O << ", "; 
    printOperand(MI, 2, O); 
    return;
    break;
  case 9:
    // MOV128rm
    O << "\n\tlg\t"; 
    printOperand(MI, 0, O, "subreg_even"); 
    O << ", 8+"; 
    printRRIAddrOperand(MI, 1, O); 
    return;
    break;
  case 10:
    // MOV128rr, MOV64rrP
    printOperand(MI, 1, O, "subreg_odd"); 
    break;
  case 11:
    // MOV32ri16, MOV64ri16
    printS16ImmOperand(MI, 1, O); 
    return;
    break;
  case 12:
    // MOV64Prm
    O << "\n\tl\t"; 
    printOperand(MI, 0, O, "subreg_even"); 
    O << ", 4+"; 
    printRRIAddrOperand(MI, 1, O); 
    return;
    break;
  case 13:
    // MOV64Prmy
    O << "\n\tly\t"; 
    printOperand(MI, 0, O, "subreg_even"); 
    O << ", 4+"; 
    printRRIAddrOperand(MI, 1, O); 
    return;
    break;
  }


  // Fragment 3 encoded into 2 bits for 4 unique commands.
  switch ((Bits >> 18) & 3) {
  default:   // unreachable.
  case 0:
    // ADC32rr, ADC64rr, ADD32rr, ADD64rr, ADDE32rr, ADDE64rr, AND32ri, AND32...
    return;
    break;
  case 1:
    // FCOPYSIGN32, FCOPYSIGN64, MOV32rmm, MOV64rmm, ROTL32rri, ROTL64rri, SH...
    O << ", "; 
    break;
  case 2:
    // MOV128rr
    O << "\n\tlgr\t"; 
    printOperand(MI, 0, O, "subreg_even"); 
    O << ", "; 
    printOperand(MI, 1, O, "subreg_even"); 
    return;
    break;
  case 3:
    // MOV64rrP
    O << "\n\tlr\t"; 
    printOperand(MI, 0, O, "subreg_even"); 
    O << ", "; 
    printOperand(MI, 1, O, "subreg_even"); 
    return;
    break;
  }


  // Fragment 4 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 17) & 1) {
    // MOV32rmm, MOV64rmm, ROTL32rri, ROTL64rri, SHL64rri, SRA64rri, SRL64rri
    printRIAddrOperand(MI, 2, O); 
    return;
  } else {
    // FCOPYSIGN32, FCOPYSIGN64
    printOperand(MI, 1, O); 
    return;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *SystemZAsmPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 82 && "Invalid register number!");

  static const unsigned RegAsmOffset[] = {
    0, 3, 6, 6, 9, 9, 12, 12, 15, 15, 18, 18, 21, 21, 
    24, 24, 27, 27, 30, 30, 33, 33, 37, 37, 41, 41, 45, 45, 
    49, 49, 53, 53, 57, 61, 61, 61, 61, 64, 64, 67, 67, 67, 
    67, 70, 70, 73, 73, 73, 73, 76, 76, 79, 79, 79, 79, 82, 
    82, 85, 85, 85, 85, 88, 88, 91, 91, 91, 91, 95, 95, 99, 
    99, 99, 99, 103, 103, 107, 107, 107, 107, 111, 111, 0
  };

  const char *AsmStrs =
    "f0\000f0\000f1\000f2\000f3\000f4\000f5\000f6\000f7\000f8\000f9\000f10\000"
    "f11\000f12\000f13\000f14\000f15\000psw\000r0\000r1\000r2\000r3\000r4\000"
    "r5\000r6\000r7\000r8\000r9\000r10\000r11\000r12\000r13\000r14\000r15\000";
  return AsmStrs+RegAsmOffset[RegNo-1];
}


#ifdef GET_INSTRUCTION_NAME
#undef GET_INSTRUCTION_NAME

/// getInstructionName: This method is automatically generated by tblgen
/// from the instruction set description.  This returns the enum name of the
/// specified instruction.
const char *SystemZAsmPrinter::getInstructionName(unsigned Opcode) {
  assert(Opcode < 287 && "Invalid instruction number!");

  static const unsigned InstAsmOffset[] = {
    0, 4, 14, 27, 36, 45, 50, 65, 79, 92, 106, 123, 133, 146, 
    151, 159, 167, 177, 185, 193, 203, 211, 220, 228, 238, 248, 256, 264, 
    273, 282, 299, 314, 322, 334, 346, 354, 363, 371, 383, 395, 407, 419, 
    431, 443, 451, 459, 469, 479, 489, 499, 509, 519, 525, 531, 539, 547, 
    556, 564, 574, 582, 590, 602, 614, 623, 632, 641, 650, 659, 668, 678, 
    688, 697, 706, 715, 724, 734, 747, 757, 770, 780, 793, 803, 816, 828, 
    840, 849, 858, 867, 876, 886, 896, 904, 914, 924, 934, 944, 953, 963, 
    972, 982, 991, 1000, 1010, 1019, 1029, 1038, 1048, 1058, 1068, 1078, 1087, 1096, 
    1105, 1114, 1124, 1134, 1143, 1152, 1164, 1174, 1184, 1194, 1204, 1213, 1222, 1231, 
    1240, 1243, 1246, 1250, 1253, 1257, 1261, 1265, 1270, 1274, 1278, 1283, 1287, 1292, 
    1297, 1301, 1304, 1310, 1317, 1326, 1335, 1344, 1358, 1367, 1376, 1384, 1394, 1405, 
    1414, 1424, 1434, 1442, 1451, 1460, 1470, 1478, 1487, 1496, 1504, 1513, 1523, 1537, 
    1546, 1556, 1566, 1577, 1587, 1598, 1607, 1617, 1627, 1635, 1644, 1654, 1664, 1676, 
    1688, 1700, 1712, 1724, 1736, 1744, 1753, 1761, 1770, 1777, 1785, 1797, 1810, 1821, 
    1833, 1844, 1856, 1868, 1879, 1891, 1903, 1914, 1926, 1937, 1949, 1961, 1972, 1984, 
    1992, 2002, 2010, 2019, 2027, 2037, 2047, 2055, 2063, 2072, 2084, 2092, 2100, 2110, 
    2114, 2121, 2130, 2140, 2147, 2155, 2162, 2173, 2184, 2195, 2206, 2217, 2228, 2235, 
    2242, 2246, 2256, 2266, 2274, 2282, 2292, 2300, 2311, 2322, 2333, 2344, 2353, 2362, 
    2371, 2380, 2389, 2398, 2406, 2415, 2423, 2431, 2439, 2448, 2457, 2466, 2475, 2485, 
    2495, 2504, 2513, 2523, 2532, 2543, 2552, 2561, 2574, 2587, 2598, 2609, 2620, 2631, 
    2642, 2652, 2660, 2668, 2677, 2685, 2693, 0
  };

  const char *Strs =
    "PHI\000INLINEASM\000PROLOG_LABEL\000EH_LABEL\000GC_LABEL\000KILL\000EXT"
    "RACT_SUBREG\000INSERT_SUBREG\000IMPLICIT_DEF\000SUBREG_TO_REG\000COPY_T"
    "O_REGCLASS\000DBG_VALUE\000REG_SEQUENCE\000COPY\000ADC32ri\000ADC32rr\000"
    "ADC64ri32\000ADC64rr\000ADD32ri\000ADD32ri16\000ADD32rm\000ADD32rmy\000"
    "ADD32rr\000ADD64ri16\000ADD64ri32\000ADD64rm\000ADD64rr\000ADDE32rr\000"
    "ADDE64rr\000ADJCALLSTACKDOWN\000ADJCALLSTACKUP\000AND32ri\000AND32rilh1"
    "6\000AND32rill16\000AND32rm\000AND32rmy\000AND32rr\000AND64rihh16\000AN"
    "D64rihi32\000AND64rihl16\000AND64rilh16\000AND64rill16\000AND64rilo32\000"
    "AND64rm\000AND64rr\000BSWAP32mr\000BSWAP32rm\000BSWAP32rr\000BSWAP64mr\000"
    "BSWAP64rm\000BSWAP64rr\000CALLi\000CALLr\000CMP32ri\000CMP32rm\000CMP32"
    "rmy\000CMP32rr\000CMP64ri32\000CMP64rm\000CMP64rr\000CMPSX64rm32\000CMP"
    "SX64rr32\000FABS32rr\000FABS64rr\000FADD32rm\000FADD32rr\000FADD64rm\000"
    "FADD64rr\000FBCONVF64\000FBCONVG64\000FCMP32rm\000FCMP32rr\000FCMP64rm\000"
    "FCMP64rr\000FCONVFP32\000FCONVFP32r64\000FCONVFP64\000FCONVFP64r32\000F"
    "CONVGR32\000FCONVGR32r64\000FCONVGR64\000FCONVGR64r32\000FCOPYSIGN32\000"
    "FCOPYSIGN64\000FDIV32rm\000FDIV32rr\000FDIV64rm\000FDIV64rr\000FEXT32m6"
    "4\000FEXT32r64\000FLOGR64\000FMADD32rm\000FMADD32rr\000FMADD64rm\000FMA"
    "DD64rr\000FMOV32mr\000FMOV32mry\000FMOV32rm\000FMOV32rmy\000FMOV32rr\000"
    "FMOV64mr\000FMOV64mry\000FMOV64rm\000FMOV64rmy\000FMOV64rr\000FMSUB32rm"
    "\000FMSUB32rr\000FMSUB64rm\000FMSUB64rr\000FMUL32rm\000FMUL32rr\000FMUL"
    "64rm\000FMUL64rr\000FNABS32rr\000FNABS64rr\000FNEG32rr\000FNEG64rr\000F"
    "ROUND64r32\000FSQRT32rm\000FSQRT32rr\000FSQRT64rm\000FSQRT64rr\000FSUB3"
    "2rm\000FSUB32rr\000FSUB64rm\000FSUB64rr\000JE\000JH\000JHE\000JL\000JLE"
    "\000JLH\000JMP\000JMPr\000JNE\000JNH\000JNHE\000JNL\000JNLE\000JNLH\000"
    "JNO\000JO\000LA64r\000LA64rm\000LD_Fp032\000LD_Fp064\000MOV128mr\000MOV"
    "128r0_even\000MOV128rm\000MOV128rr\000MOV16mi\000MOV32m16r\000MOV32m16r"
    "y\000MOV32m8r\000MOV32m8ry\000MOV32mi16\000MOV32mr\000MOV32mrm\000MOV32"
    "mry\000MOV32ri16\000MOV32rm\000MOV32rmm\000MOV32rmy\000MOV32rr\000MOV64"
    "Pmr\000MOV64Pmry\000MOV64Pr0_even\000MOV64Prm\000MOV64Prmy\000MOV64m16r"
    "\000MOV64m16ry\000MOV64m32r\000MOV64m32ry\000MOV64m8r\000MOV64m8ry\000M"
    "OV64mi16\000MOV64mr\000MOV64mrm\000MOV64ri16\000MOV64ri32\000MOV64rihh1"
    "6\000MOV64rihi32\000MOV64rihl16\000MOV64rilh16\000MOV64rill16\000MOV64r"
    "ilo32\000MOV64rm\000MOV64rmm\000MOV64rr\000MOV64rrP\000MOV8mi\000MOV8mi"
    "y\000MOVSX32rm16\000MOVSX32rm16y\000MOVSX32rm8\000MOVSX32rr16\000MOVSX3"
    "2rr8\000MOVSX64rm16\000MOVSX64rm32\000MOVSX64rm8\000MOVSX64rr16\000MOVS"
    "X64rr32\000MOVSX64rr8\000MOVZX32rm16\000MOVZX32rm8\000MOVZX64rm16\000MO"
    "VZX64rm32\000MOVZX64rm8\000MOVZX64rr32\000MUL32ri\000MUL32ri16\000MUL32"
    "rm\000MUL32rmy\000MUL32rr\000MUL64ri16\000MUL64ri32\000MUL64rm\000MUL64"
    "rr\000MUL64rrP\000MULSX64rr32\000NEG32rr\000NEG64rr\000NEG64rr32\000NOP"
    "\000OR32ri\000OR32ri16\000OR32ri16h\000OR32rm\000OR32rmy\000OR32rr\000O"
    "R64rihh16\000OR64rihi32\000OR64rihl16\000OR64rilh16\000OR64rill16\000OR"
    "64rilo32\000OR64rm\000OR64rr\000RET\000ROTL32rri\000ROTL64rri\000SBC32r"
    "i\000SBC32rr\000SBC64ri32\000SBC64rr\000SDIVREM32m\000SDIVREM32r\000SDI"
    "VREM64m\000SDIVREM64r\000SHL32rri\000SHL64rri\000SRA32rri\000SRA64rri\000"
    "SRL32rri\000SRL64rri\000SUB32rm\000SUB32rmy\000SUB32rr\000SUB64rm\000SU"
    "B64rr\000SUBE32rr\000SUBE64rr\000Select32\000Select64\000SelectF32\000S"
    "electF64\000UCMP32ri\000UCMP32rm\000UCMP32rmy\000UCMP32rr\000UCMP64ri32"
    "\000UCMP64rm\000UCMP64rr\000UCMPZX64rm32\000UCMPZX64rr32\000UDIVREM32m\000"
    "UDIVREM32r\000UDIVREM64m\000UDIVREM64r\000UMUL128rrP\000UMUL64rrP\000XO"
    "R32ri\000XOR32rm\000XOR32rmy\000XOR32rr\000XOR64rm\000XOR64rr\000";
  return Strs+InstAsmOffset[Opcode];
}

#endif
