//===- TableGen'erated file -------------------------------------*- C++ -*-===//
//
// Assembly Writer Source Fragment
//
// Automatically generated file, do not edit!
//
//===----------------------------------------------------------------------===//

/// printInstruction - This method is automatically generated by tablegen
/// from the instruction set description.
void PIC16AsmPrinter::printInstruction(const MachineInstr *MI, raw_ostream &O) {
  static const unsigned OpInfo[] = {
    0U,	// PHI
    0U,	// INLINEASM
    0U,	// PROLOG_LABEL
    0U,	// EH_LABEL
    0U,	// GC_LABEL
    0U,	// KILL
    0U,	// EXTRACT_SUBREG
    0U,	// INSERT_SUBREG
    0U,	// IMPLICIT_DEF
    0U,	// SUBREG_TO_REG
    0U,	// COPY_TO_REGCLASS
    1U,	// DBG_VALUE
    0U,	// REG_SEQUENCE
    0U,	// COPY
    536870923U,	// ADJCALLSTACKDOWN
    536870942U,	// ADJCALLSTACKUP
    1073741871U,	// AndFW
    1677721647U,	// AndWF
    536870966U,	// CALL
    60U,	// CALLW
    60U,	// CALL_1
    1073741890U,	// OrFW
    1677721666U,	// OrWF
    73U,	// Return
    80U,	// SELECT_CC_Int_ICC
    1073741932U,	// XOrFW
    1677721708U,	// XOrWF
    1073741939U,	// addfw_1
    1073741939U,	// addfw_2
    1073741946U,	// addfwc
    1610612866U,	// addlw_1
    1610612866U,	// addlw_2
    1610612873U,	// addlwc
    1677721715U,	// addwf_1
    1677721715U,	// addwf_2
    1677721722U,	// addwfc
    1610612881U,	// andlw
    536871064U,	// banksel
    536871073U,	// br_uncond
    671088807U,	// copy_fsr
    671088817U,	// copy_w
    1811939513U,	// load_indirect
    1686110400U,	// movf
    1686110400U,	// movf_1
    1686110400U,	// movf_1_1
    1686110400U,	// movf_2
    2147483846U,	// movlw
    2248147149U,	// movlw_hi_1
    2248147149U,	// movlw_hi_2
    2248147161U,	// movlw_lo_1
    2248147161U,	// movlw_lo_2
    1694499044U,	// movwf
    1694499044U,	// movwf_1
    1694499044U,	// movwf_2
    1610612971U,	// orlw
    536871154U,	// pagesel
    2684354809U,	// pic16brcond
    1744830715U,	// restore_fsr0
    1744830729U,	// restore_fsr1
    1744830743U,	// save_fsr0
    1744830754U,	// save_fsr1
    805306596U,	// set_fsrhi
    872415460U,	// set_fsrlo
    536871140U,	// set_pclath
    1811939629U,	// store_indirect
    1073742132U,	// subfw_1
    1073742132U,	// subfw_2
    1073742132U,	// subfw_cc
    1073742139U,	// subfwb
    1610613059U,	// sublw_1
    1610613059U,	// sublw_2
    1610613066U,	// sublw_3
    1610613074U,	// sublw_4
    1610613074U,	// sublw_5
    1610613081U,	// sublw_6
    1610613059U,	// sublw_cc
    1694499124U,	// subwf_1
    1694499124U,	// subwf_2
    1694499124U,	// subwf_cc
    1694499131U,	// subwfb
    1610613089U,	// xorlw
    0U
  };

  const char *AsmStrs = 
    "DBG_VALUE\000!ADJCALLSTACKDOWN \000!ADJCALLSTACKUP \000andwf \000call \000"
    "callw\000iorwf \000return\000; SELECT_CC_Int_ICC PSEUDO!\000xorwf \000a"
    "ddwf \000addwfc \000addlw \000addlwc \000andlw \000banksel \000goto \000"
    "copy_fsr \000copy_w \000moviw \000movf \000movlw \000movlw HIGH(\000mov"
    "lw LOW(\000movwf \000iorlw \000movlp \000b\000restore_fsr0 \000restore_"
    "fsr1 \000save_fsr0 \000save_fsr1 \000movwi \000subwf \000subwfb \000sub"
    "lw \000sublwb \000subwl \000subwlb \000xorlw \000";

  O << "\t";

  // Emit the opcode for the instruction.
  unsigned Bits = OpInfo[MI->getOpcode()];
  assert(Bits != 0 && "Cannot print this instruction.");
  O << AsmStrs+(Bits & 511)-1;


  // Fragment 0 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 29) & 7) {
  default:   // unreachable.
  case 0:
    // DBG_VALUE, CALLW, CALL_1, Return, SELECT_CC_Int_ICC
    return;
    break;
  case 1:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, CALL, banksel, br_uncond, copy_fsr, ...
    printOperand(MI, 0, O); 
    break;
  case 2:
    // AndFW, OrFW, XOrFW, addfw_1, addfw_2, addfwc, subfw_1, subfw_2, subfw_...
    printOperand(MI, 3, O); 
    O << " + "; 
    printOperand(MI, 2, O); 
    O << ", W"; 
    return;
    break;
  case 3:
    // AndWF, OrWF, XOrWF, addlw_1, addlw_2, addlwc, addwf_1, addwf_2, addwfc...
    printOperand(MI, 2, O); 
    break;
  case 4:
    // movlw, movlw_hi_1, movlw_hi_2, movlw_lo_1, movlw_lo_2
    printOperand(MI, 1, O); 
    break;
  case 5:
    // pic16brcond
    printCCOperand(MI, 1, O); 
    O << ' '; 
    printOperand(MI, 0, O); 
    return;
    break;
  }


  // Fragment 1 encoded into 3 bits for 6 unique commands.
  switch ((Bits >> 26) & 7) {
  default:   // unreachable.
  case 0:
    // ADJCALLSTACKDOWN, ADJCALLSTACKUP, CALL, addlw_1, addlw_2, addlwc, andl...
    return;
    break;
  case 1:
    // AndWF, OrWF, XOrWF, addwf_1, addwf_2, addwfc, movf, movf_1, movf_1_1, ...
    O << " + "; 
    break;
  case 2:
    // copy_fsr, copy_w, restore_fsr0, restore_fsr1, save_fsr0, save_fsr1
    O << ", "; 
    printOperand(MI, 1, O); 
    return;
    break;
  case 3:
    // load_indirect, store_indirect
    O << '['; 
    printOperand(MI, 1, O); 
    O << ']'; 
    return;
    break;
  case 4:
    // set_fsrhi
    O << 'H'; 
    return;
    break;
  case 5:
    // set_fsrlo
    O << 'L'; 
    return;
    break;
  }


  // Fragment 2 encoded into 1 bits for 2 unique commands.
  if ((Bits >> 25) & 1) {
    // movlw_hi_1, movlw_hi_2, movlw_lo_1, movlw_lo_2
    printOperand(MI, 2, O); 
    O << ')'; 
    return;
  } else {
    // AndWF, OrWF, XOrWF, addwf_1, addwf_2, addwfc, movf, movf_1, movf_1_1, ...
    printOperand(MI, 1, O); 
  }


  // Fragment 3 encoded into 2 bits for 3 unique commands.
  switch ((Bits >> 23) & 3) {
  default:   // unreachable.
  case 0:
    // AndWF, OrWF, XOrWF, addwf_1, addwf_2, addwfc
    O << ", F"; 
    return;
    break;
  case 1:
    // movf, movf_1, movf_1_1, movf_2
    O << ", W"; 
    return;
    break;
  case 2:
    // movwf, movwf_1, movwf_2, subwf_1, subwf_2, subwf_cc, subwfb
    return;
    break;
  }

}


/// getRegisterName - This method is automatically generated by tblgen
/// from the register set description.  This returns the assembler name
/// for the specified register.
const char *PIC16AsmPrinter::getRegisterName(unsigned RegNo) {
  assert(RegNo && RegNo < 7 && "Invalid register number!");

  static const unsigned RegAsmOffset[] = {
    0, 3, 8, 13, 20, 27, 0
  };

  const char *AsmStrs =
    "BS\000FSR0\000FSR1\000PCLATH\000STATUS\000W\000";
  return AsmStrs+RegAsmOffset[RegNo-1];
}


#ifdef GET_INSTRUCTION_NAME
#undef GET_INSTRUCTION_NAME

/// getInstructionName: This method is automatically generated by tblgen
/// from the instruction set description.  This returns the enum name of the
/// specified instruction.
const char *PIC16AsmPrinter::getInstructionName(unsigned Opcode) {
  assert(Opcode < 81 && "Invalid instruction number!");

  static const unsigned InstAsmOffset[] = {
    0, 4, 14, 27, 36, 45, 50, 65, 79, 92, 106, 123, 133, 146, 
    151, 168, 183, 189, 195, 200, 206, 213, 218, 223, 230, 248, 254, 260, 
    268, 276, 283, 291, 299, 306, 314, 322, 329, 335, 343, 353, 362, 369, 
    383, 388, 395, 404, 411, 417, 428, 439, 450, 461, 467, 475, 483, 488, 
    496, 508, 521, 534, 544, 554, 564, 574, 585, 600, 608, 616, 625, 632, 
    640, 648, 656, 664, 672, 680, 689, 697, 705, 714, 721, 0
  };

  const char *Strs =
    "PHI\000INLINEASM\000PROLOG_LABEL\000EH_LABEL\000GC_LABEL\000KILL\000EXT"
    "RACT_SUBREG\000INSERT_SUBREG\000IMPLICIT_DEF\000SUBREG_TO_REG\000COPY_T"
    "O_REGCLASS\000DBG_VALUE\000REG_SEQUENCE\000COPY\000ADJCALLSTACKDOWN\000"
    "ADJCALLSTACKUP\000AndFW\000AndWF\000CALL\000CALLW\000CALL_1\000OrFW\000"
    "OrWF\000Return\000SELECT_CC_Int_ICC\000XOrFW\000XOrWF\000addfw_1\000add"
    "fw_2\000addfwc\000addlw_1\000addlw_2\000addlwc\000addwf_1\000addwf_2\000"
    "addwfc\000andlw\000banksel\000br_uncond\000copy_fsr\000copy_w\000load_i"
    "ndirect\000movf\000movf_1\000movf_1_1\000movf_2\000movlw\000movlw_hi_1\000"
    "movlw_hi_2\000movlw_lo_1\000movlw_lo_2\000movwf\000movwf_1\000movwf_2\000"
    "orlw\000pagesel\000pic16brcond\000restore_fsr0\000restore_fsr1\000save_"
    "fsr0\000save_fsr1\000set_fsrhi\000set_fsrlo\000set_pclath\000store_indi"
    "rect\000subfw_1\000subfw_2\000subfw_cc\000subfwb\000sublw_1\000sublw_2\000"
    "sublw_3\000sublw_4\000sublw_5\000sublw_6\000sublw_cc\000subwf_1\000subw"
    "f_2\000subwf_cc\000subwfb\000xorlw\000";
  return Strs+InstAsmOffset[Opcode];
}

#endif
